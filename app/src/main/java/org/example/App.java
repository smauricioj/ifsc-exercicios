/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;

import java.util.Arrays;
import java.util.Objects;
import java.util.Scanner;

public class App {
    // Implemente um programa que LÊ do teclado três números reais a, b e c, representando os coeficientes
    // de uma equação de segundo grau, e ESCREVE o valor do discriminante ∆ = b^2 − 4ac da equação.

    static void exercicio1() {
        Scanner sc = new Scanner(System.in);
        float a, b, c;
        System.out.print("Digite o valor de a: ");
        a = sc.nextFloat();
        System.out.print("Digite o valor de b: ");
        b = sc.nextFloat();
        System.out.print("Digite o valor de c: ");
        c = sc.nextFloat();
        System.out.printf("O valor do discriminante é %.2f\n", (b*b)-(4*a*c));
    }

    // Implemente um programa que LÊ do teclado as seis notas de um aluno e a presença (entre 0 e 100), e
    // ESCREVE o seu resultado R e se o aluno foi aprovado ou reprovado.

    static void exercicio2() {
        Scanner sc = new Scanner(System.in);
        byte[] P  = lerValores((byte) 4, "prova"  , sc);
        byte[] Pj = lerValores((byte) 2, "projeto", sc);
        System.out.print("Digite a presença (em %): ");
        byte pre = sc.nextByte();
        double mediaP = media(P), mediaPj = media(Pj);
        byte R = (mediaP >= 6 && mediaPj >= 6) ? (byte) Math.round( (3 * mediaP + 2 * mediaPj) / 5 ) : 0;
        System.out.printf("R: %d | Situacao: %s", R, (R >= 6 && pre >= 75) ? "Aprovado" : "Reprovado");
    }

    static byte[] lerValores(byte tam, String nome, Scanner sc) {
        byte[] valores = new byte[tam];
        for (byte i = 0; i < tam; i++) {
            System.out.printf("Digite o valor de %s %d: ", nome, i+1);
            valores[i] = sc.nextByte();
        }
        return valores;
    }

    static double media(byte[] arr) {
        double m = 0;
        for (byte b : arr) m += b;
        return m / arr.length;
    }

    // Implemente um programa que RECEBE cinco argumentos na linha de comando que representam os cinco
    // bits da representação binária de um número (por exemplo, ./gradlew run - -args "1 0 0 1 1"), e ESCREVE
    // esse número em representação decimal. Assuma que os bits são informados do mais significativo para
    // o menos (da esquerda para direita). Se os argumentos informados não estiverem dentro do padrão
    // (quantidade, valores, formato), o programa deve imprimir uma mensagem de erro e abordar a execução.

    static void exercicio3(String[] args) {
        if (args.length != 5) {
            System.out.println("Erro: não possui 5 argumentos.");
            return;
        }
        byte valor = 0;
        for (int i = 0; i < args.length; i++) {
            if (!args[i].equals("1") && !args[i].equals("0")) {
                System.out.printf("Erro: argumento '%s' nao é binário.\n", args[i]);
                return;
            }
            if (args[i].equals("1")) valor += (byte) Math.pow(2, 4-i);
        }
        System.out.printf("Valor: %d\n", valor);
    }

    // Junto com essa lista de exercícios existe um arquivo chamado valores.csv que contém os valores ordenados
    // de um vetor para realizar buscas. Implemente um programa para buscar elementos nesse conjunto de
    // valores. O programa RECEBE a chave via argumento da linha de comandos, LÊ os valores do arquivo via
    // redirecionamento de entrada, e ESCREVE no terminal o índice da chave no vetor se estiver presente, ou
    // Ausente caso contrário.

    static void exercicio4(String[] args) {
        if (args.length != 1) {
            System.out.println("Erro: não possui 1 argumento.");
            return;
        }
        int chave = Integer.parseInt(args[0]);
        Scanner sc = new Scanner(System.in);
        String[] valoresTexto = sc.nextLine().split(";");
        int[] valores = new int[valoresTexto.length];
        for (int i = 0; i < valoresTexto.length; i++) {
            valores[i] = Integer.parseInt(valoresTexto[i]);
        }
        int index = buscaBinaria(valores, chave);
        System.out.println("Index: "+((index != -1) ? index : "ausente"));
    }

    static int buscaBinaria(int[] V, int chave) {
        int L = 0, R = V.length, M;
        do {
            M = (L + R) / 2;
            if (V[M] == chave) {
                return M;
            } else if (V[M] > chave) {
                R = M - 1;
            } else {
                L = M + 1;
            }
        } while(L <= R);
        return -1;
    }

    // Implemente um programa que LÊ do teclado um texto e ESCREVE a versão criptografada desse texto em
    // um arquivo de texto. Use redirecionamento de saída para escrever no arquivo. Caso existam caracteres
    // não alfabéticos no texto (pontuação, números, espaços), deixe-os intactos.

    static void exercicio5() {
        Scanner sc = new Scanner(System.in);
        String texto = sc.nextLine();
        char[] letras = texto.toCharArray();
        char[][] faixas = {{'a', 'z'}, {'A', 'Z'}};
        for (int i = 0; i < letras.length; i++) {
            for (char[] faixa : faixas) {
                if (letras[i] >= faixa[0] && letras[i] <= faixa[1]) {
                    letras[i]  = (char) (((letras[i] - faixa[0] + 3) % 26) + faixa[0]);
                }
            }
        }
        System.out.println(new String(letras));
    }

    // Implemente um programa que calcule o desvio padrão δ de um vetor v contendo n = 10 números reais,
    // onde m é a média dos valores. (eu fiz para os números em valores.csv)
    static void exercicio6() {
        Scanner sc = new Scanner(System.in);
        String[] valoresTexto = sc.nextLine().split(";");
        int[] valores = new int[valoresTexto.length];
        for (int i = 0; i < valoresTexto.length; i++) {
            valores[i] = Integer.parseInt(valoresTexto[i]);
        }
        double m = media(valores), sum = 0;
        for (int valor : valores)  sum += Math.pow((valor-m), 2);
        double dp = Math.sqrt(sum / (valores.length - 1));
        System.out.printf("%.2f\n", dp);
    }

    static double media(int[] arr) {
        double m = 0.0;
        for (int v : arr) m += v;
        return m / arr.length;
    }

    // Implemente um programa que LÊ um número inteiro positivo n e em seguida imprima n linhas do Triângulo
    //  de Pascal.
    static void exercicio7(){
        Scanner sc = new Scanner(System.in);
        int n = -1;
        do {
            System.out.print("Digite o valor de n: ");
            n = sc.nextInt();
        } while (n < 0);
        int[] linhaAtual = new int[n], linhaAnterior = new int[n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= i; j++) {
                linhaAtual[j] = (j == 0 || j == i) ? 1 : linhaAnterior[j - 1] + linhaAnterior[j];
                System.out.print(linhaAtual[j] + " ");
            }
            System.out.println();
            System.arraycopy(linhaAtual, 0, linhaAnterior, 0, i + 1);
        }
    }

    // Implemente um programa que gera uma matriz de tamanho 5 × 5, preenche a diagonal principal com 1 e
    // os demais elementos com 0 e ESCREVE a matriz no terminal de forma legível.
    static void exercicio8(){
        byte[][] mat = new byte[5][5];
        for (int i = 0; i < 5; i++) {
            for (int j = 0; j < 5; j++) {
                mat[i][j] = (byte) ((i == j) ? 1 : 0);
                System.out.print(mat[i][j] + " ");
            }
            System.out.println();
        }
    }

    // Implemente um programa que gera uma matriz A de tamanho 10 × 10 onde seus elementos obedecem a
    // seguinte equação (no pdf)
    // Em seguida, o programa ESCREVE a matriz para um arquivo de texto usando redirecionamento de saída.

    static void exercicio9(){
        byte tam = 10;
        int[][] mat = new int[tam][tam];
        for (int i = 0; i < tam; i++) {
            for (int j = 0; j < tam; j++) {
                if (i < j) {
                    mat[i][j] = (2 * i) + (7 * j) - 2;
                }
                else if (i == j) {
                    mat[i][j] = (3 * i * i) - 1;
                } else {
                    mat[i][j] = (4 * i * i * i) - (5 * j * j);
                }
                System.out.print(mat[i][j] + " ");
            }
            System.out.println();
        }

    }


    static int produto(int[][] mat, int i, int j, int di, int dj) {
        int comp = 4, ci = i + (comp - 1)*di, cj = j + (comp - 1)*dj;
        if (ci >= mat.length || ci < 0 || cj >= mat[0].length || cj < 0) return Integer.MIN_VALUE;
        int valor = 1;
        for (int k = 0; k < comp; k++) valor *= mat[i + (k * di)][j + (k * dj)];
        return valor;
    }

    static void exercicioMatriz() {
        // Variáveis
        int tam = 20;
        int[][] matriz = new int[tam][tam];
        Scanner scan = new Scanner(System.in);

        // Ler a matriz
        int i = 0, j = 0;
        while(scan.hasNext()){
            matriz[i][j++] = scan.nextInt();
            if (j == tam) {
                j = 0;
                i++;
            }
        }

        // Buscar maior valor
        int maior = 0;
        for(i = 0; i < tam; i++){
            for(j = 0; j < tam; j++){
                maior = Math.max(maior, produto(matriz, i, j, 0, 1));
                maior = Math.max(maior, produto(matriz, i, j, 1, 0));
                maior = Math.max(maior, produto(matriz, i, j, 1, 1));
                maior = Math.max(maior, produto(matriz, i, j, 1, -1));
            }
        }

        // Imprime
        System.out.println(maior);
    }


    public static void main(String[] args) {
//        exercicioMatriz();
//        exercicio2();
//        exercicio3(args);
//        exercicio4(args);
//        exercicio5();
//        exercicio6();
//        exercicio7();
        exercicio9();
    }

}
